package com.hedera.services.legacy.proto.utils;

/*-
 * ‌
 * Hedera Services API
 * ​
 * Copyright (C) 2018 - 2021 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.nio.file.Files;
import java.security.AlgorithmParameters;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.SignatureException;
import java.security.interfaces.ECPublicKey;
import java.security.spec.ECGenParameterSpec;
import java.security.spec.ECParameterSpec;
import java.security.spec.ECPoint;
import java.security.spec.ECPublicKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.HashMap;
import java.util.Map;
import net.i2p.crypto.eddsa.EdDSAEngine;
import net.i2p.crypto.eddsa.EdDSAPrivateKey;
import net.i2p.crypto.eddsa.EdDSAPublicKey;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;

public class SignatureGenerator {

  /**
   * map key name for public key
   */
  public static final String PUBLIC_KEY_HEX = "PUBLIC_KEY_HEX";
  /**
   * map key name for signature
   */
  public static final String SIGNATURE_HEX = "SIGNATURE_HEX";
  /**
   * Named EC curve used to read a public key generated by iOS
   */
  private static final String NAMED_EC_CURVE = "secp384r1";
  /**
   * Directory for saving key pairs
   */
  public static final String KEY_SAVE_DIR = "data/keys/";

  // Signature Algorithm Type Constants
  public static String ECDSA = "ECDSA";
  public static String ED25519 = "ED25519";
  public static String RSA = "RSA";

  /**
   * Signs a message with a auto-generated key pair and return both the signature and the public key
   * as Hex encoded strings in a map.
   *
   * @param msg the data signed
   * @param pair the keypair for signing
   * @return map with the public key in hex and the signature in hex as the two entries
   */
  public static Map<String, String> sign(String msg, KeyPair pair) throws SignatureException,
      UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException {
    Map<String, String> rv = new HashMap<>();

    PrivateKey priv = pair.getPrivate();
    String sigHex = sign(msg, priv);
    String pubKeyHex = getPubKeyHex(pair);
    rv.put(PUBLIC_KEY_HEX, pubKeyHex);
    rv.put(SIGNATURE_HEX, sigHex);
    return rv;
  }

  /**
   * Signs a message with a private key.
   *
   * @param msg to be signed
   * @param priv private key
   * @return signature in hex format
   */
  public static String sign(String msg, PrivateKey priv)
      throws NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException, SignatureException {
    // Create a Signature object and initialize it with the private key
    byte[] sigBytes = null;
    byte[] msgBytes = SignatureVerifier.getMsgBytes(msg);
    if (priv instanceof EdDSAPrivateKey) {
      EdDSAEngine engine = new EdDSAEngine();
      engine.initSign(priv);
      sigBytes = engine.signOneShot(msgBytes);
    } else {
      Signature sigInstance = Signature.getInstance(SignatureVerifier.SIGNATURE_ALGORITHM);
      sigInstance.initSign(priv);
      // Update and sign the data
      sigInstance.update(msgBytes, 0, msgBytes.length);
      sigBytes = sigInstance.sign();
    }

    String sigHex = Hex.encodeHexString(sigBytes);
    return sigHex;
  }

  /**
   * Signs a message with a private key.
   *
   * @param msgBytes to be signed
   * @param priv private key
   * @return signature in hex format
   */
  public static String signBytes(byte[] msgBytes, PrivateKey priv)
      throws NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException, SignatureException {
    // Create a Signature object and initialize it with the private key
    byte[] sigBytes = null;
    if (priv instanceof EdDSAPrivateKey) {
      EdDSAEngine engine = new EdDSAEngine();
      engine.initSign(priv);
      sigBytes = engine.signOneShot(msgBytes);
    } else {
      Signature sigInstance = Signature.getInstance(SignatureVerifier.SIGNATURE_ALGORITHM);
      sigInstance.initSign(priv);
      // Update and sign the data
      sigInstance.update(msgBytes, 0, msgBytes.length);
      sigBytes = sigInstance.sign();
    }

    String sigHex = Hex.encodeHexString(sigBytes);
    return sigHex;
  }

  /**
   * Gets the public key in Hex encoding from a key pair.
   *
   * @param pair key pair
   * @return public key in Hex
   */
  public static String getPubKeyHex(KeyPair pair) {
    byte[] pubKeyBytes = null;
    PublicKey pub = pair.getPublic();
    if (pub instanceof EdDSAPublicKey) {
      pubKeyBytes = ((EdDSAPublicKey) pair.getPublic()).getAbyte();
    } else {
      pubKeyBytes = pub.getEncoded();
    }
    String pubKeyHex = Hex.encodeHexString(pubKeyBytes);
    return pubKeyHex;
  }

  /**
   * Signs a message with a auto-generated key pair and return both the signature and the public key
   * as Hex encoded strings in a map.
   *
   * @param msg the data signed
   * @return map with the public key in hex and the signature in hex as the two entries
   */
  public static Map<String, String> sign(String msg)
      throws SignatureException, UnsupportedEncodingException,
      NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException {
    KeyPair pair = generateKeyPair();
    return sign(msg, pair);
  }

  /**
   * Extract the EC public key from the its raw binary format.
   *
   * @param x the x coordinate of the EC key's curve point
   * @param y the y coordinate of the EC key's curve point
   * @param namedCurve the name of the EC curve the public key generated on
   * @param keyAlgorithm the key generation algorithm
   * @return the EC public key instance
   */
  public static ECPublicKey getPublicKeyFromBinary(byte[] x, byte[] y, String namedCurve,
      String keyAlgorithm)
      throws NoSuchAlgorithmException, NoSuchProviderException, InvalidParameterSpecException,
      InvalidKeySpecException {
    ECPoint pubPoint = new ECPoint(new BigInteger(1, x), new BigInteger(1, y));
    AlgorithmParameters parameters = AlgorithmParameters.getInstance(keyAlgorithm);
    parameters.init(new ECGenParameterSpec(namedCurve));
    ECParameterSpec ecParameters = parameters.getParameterSpec(ECParameterSpec.class);
    ECPublicKeySpec pubSpec = new ECPublicKeySpec(pubPoint, ecParameters);
    KeyFactory kf = KeyFactory.getInstance(keyAlgorithm);
    ECPublicKey rv = (ECPublicKey) kf.generatePublic(pubSpec);
    return rv;
  }

  /**
   * Extract the EC 384 bit public key from the its raw binary format.
   *
   * @param binaryHex the hex string of the public key in raw binary format
   * @return the EC public key instance
   */
  public static ECPublicKey getEC384PublicKeyFromBinary(String binaryHex)
      throws NoSuchAlgorithmException, NoSuchProviderException, InvalidParameterSpecException,
      InvalidKeySpecException, DecoderException, StringIndexOutOfBoundsException {
    ECPublicKey key = null;
    try {
      String xHex = binaryHex.substring(2, 98);
      String yHex = binaryHex.substring(98, 194);
      byte[] x = Hex.decodeHex(xHex);
      byte[] y = Hex.decodeHex(yHex);
      key = getPublicKeyFromBinary(x, y, NAMED_EC_CURVE, SignatureVerifier.KEY_ALGORITHM);
    } catch (StringIndexOutOfBoundsException e) {
      throw e;
    }

    return key;
  }

  public static void main(String[] args) throws Exception {
    KeyPair pair = generateKeyPair();
    String path = KEY_SAVE_DIR + "/test/";
    save(pair, path);
    PrivateKey privateKey = readPrivate(path + "privateKey");
    String msg = "a test message";
    String signature = sign(msg, privateKey);
    String pubKeyStr = readPublic(path + "publicKey");
    boolean rv = SignatureVerifier.verifyECDSA(signature, msg, pubKeyStr);
    System.out.println("rv =" + rv);
  }


  /**
   * Generates a key pair.
   *
   * @return the key pair generated
   */
  public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(SignatureVerifier.KEY_ALGORITHM);
    SecureRandom random = SecureRandom.getInstance(SignatureVerifier.RANDOM_ALGORITHM);

    keyGen.initialize(SignatureVerifier.KEY_SIZE, random);

    KeyPair pair = keyGen.generateKeyPair();

    return pair;
  }

  /**
   * Write bytes to a file.
   *
   * @param path the file path to write bytes
   * @param data the byte array data
   */
  public static void writeToFile(String path, byte[] data) throws IOException {
    File f = new File(path);
    f.getParentFile().mkdirs();

    try (FileOutputStream fos = new FileOutputStream(f)) {
      fos.write(data);
      fos.flush();
    } catch ( IOException e) {
      throw e;
    }
  }

  /**
   * Save a keypair to a file in a given directory.
   *
   * @param pair the key pair to be saved
   * @param dir the directory to save
   */
  public static void save(KeyPair pair, String dir) throws IOException {
    PrivateKey privateKey = pair.getPrivate();
    PublicKey publicKey = pair.getPublic();
    if (!dir.endsWith("/")) {
      dir += "/";
    }
    writeToFile(dir + "privateKey", privateKey.getEncoded());
    writeToFile(dir + "publicKey", publicKey.getEncoded());
  }

  /**
   * Retrieves the Private Key from a file.
   *
   * @param filename the file containing the private key
   * @return the private key read
   */
  public static PrivateKey readPrivate(String filename)
      throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
    byte[] keyBytes = Files.readAllBytes(new File(filename).toPath());
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory kf = KeyFactory.getInstance(SignatureVerifier.KEY_ALGORITHM);
    return kf.generatePrivate(spec);
  }

  /**
   * Retrieves hex string of the array bytes (X509 encoding) of the Public Key from a file.
   *
   * @param filename file containing the public key
   * @return the public key byte array
   */
  public static String readPublic(String filename) throws Exception {
    byte[] keyBytes = Files.readAllBytes(new File(filename).toPath());
    String pubKeyHex = Hex.encodeHexString(keyBytes);
    return pubKeyHex;
  }

  /**
   * Generates a key pair.
   *
   * @return the key pair generated
   */
  public static KeyPair generateKeyPair(String algorithm) throws NoSuchAlgorithmException {
    KeyPair pair;
    if (algorithm.equals(ECDSA)) {
      KeyPairGenerator keyGen = KeyPairGenerator.getInstance(SignatureVerifier.KEY_ALGORITHM);
      SecureRandom random = SecureRandom.getInstance(SignatureVerifier.RANDOM_ALGORITHM);
      keyGen.initialize(SignatureVerifier.KEY_SIZE, random);
      pair = keyGen.generateKeyPair();
    } else {
      net.i2p.crypto.eddsa.KeyPairGenerator keyPairGen = new net.i2p.crypto.eddsa.KeyPairGenerator();
      pair = keyPairGen.generateKeyPair();

    }
    return pair;
  }


}
